name: Release

# Trigger on version tags: push a tag like v0.1.0 to create a release.
on:
  push:
    tags:
      - "v*"

# Allow creating GitHub Releases
permissions:
  contents: write

jobs:
  build:
    name: Build & Package
    runs-on: macos-26
    steps:
      - uses: actions/checkout@v4

      - name: Print build environment
        run: |
          xcodebuild -version
          swift --version

      - name: Build release binary
        run: cd Speak && swift build -c release

      # Import self-signed certificate for stable code identity across updates.
      # This preserves macOS TCC permissions (microphone, accessibility) through
      # Sparkle updates by keeping the same signing identity.
      #
      # One-time setup:
      #   1. Create a self-signed certificate named "Speak Signing" via
      #      Keychain Access → Certificate Assistant → Create a Certificate
      #      (type: Code Signing, 10-year validity recommended)
      #   2. Export as .p12 file with a password
      #   3. base64-encode it: base64 -i speak-signing.p12 | pbcopy
      #   4. Add GitHub repo secrets:
      #      - SIGNING_CERT_BASE64: the base64-encoded .p12
      #      - SIGNING_CERT_PASS: the .p12 password
      - name: Import signing certificate
        env:
          SIGNING_CERT_BASE64: ${{ secrets.SIGNING_CERT_BASE64 }}
          SIGNING_CERT_PASS: ${{ secrets.SIGNING_CERT_PASS }}
        run: |
          if [ -z "$SIGNING_CERT_BASE64" ]; then
            echo "SIGNING_CERT_BASE64 not set — will fall back to ad-hoc signing"
            echo "SIGNING_IDENTITY=-" >> "$GITHUB_ENV"
            exit 0
          fi
          echo "$SIGNING_CERT_BASE64" | base64 --decode > cert.p12
          security create-keychain -p "" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "" build.keychain
          security import cert.p12 -k build.keychain -P "$SIGNING_CERT_PASS" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain
          rm cert.p12
          echo "SIGNING_IDENTITY=Speak Signing" >> "$GITHUB_ENV"

      - name: Assemble .app bundle
        run: |
          BIN_PATH=$(cd Speak && swift build -c release --show-bin-path)
          APP=build/Speak.app
          VERSION="${GITHUB_REF_NAME#v}"

          mkdir -p "$APP/Contents/MacOS"
          mkdir -p "$APP/Contents/Resources"
          mkdir -p "$APP/Contents/Frameworks"

          # Binary
          cp "$BIN_PATH/Speak" "$APP/Contents/MacOS/Speak"

          # Info.plist — inject version from git tag
          cp Speak/Speak/Info.plist "$APP/Contents/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" "$APP/Contents/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" "$APP/Contents/Info.plist"

          # PkgInfo
          echo -n "APPL????" > "$APP/Contents/PkgInfo"

          # Copy SPM-compiled resource bundles (includes processed assets)
          for bundle in "$BIN_PATH"/*.bundle; do
            [ -d "$bundle" ] && cp -R "$bundle" "$APP/Contents/Resources/"
          done

          # SPM doesn't compile .xcassets into Assets.car — do it manually with actool
          BUNDLE_RESOURCE="$APP/Contents/Resources/Speak_Speak.bundle"
          XCASSETS="$BUNDLE_RESOURCE/Assets.xcassets"
          if [ -d "$XCASSETS" ]; then
            xcrun actool "$XCASSETS" \
              --compile "$BUNDLE_RESOURCE" \
              --platform macosx \
              --minimum-deployment-target 26.0 \
              --output-partial-info-plist /dev/null
            rm -rf "$XCASSETS"
          fi

          # Embed Sparkle.framework from SPM build artifacts
          SPARKLE_FRAMEWORK=$(find Speak/.build/artifacts -name "Sparkle.framework" -path "*/macos-*" -type d | head -1)
          if [ -n "$SPARKLE_FRAMEWORK" ]; then
            cp -R "$SPARKLE_FRAMEWORK" "$APP/Contents/Frameworks/"
            echo "Embedded: $SPARKLE_FRAMEWORK"
          else
            echo "ERROR: Sparkle.framework not found in SPM artifacts" && exit 1
          fi

          # Add rpath so the binary can find Sparkle.framework in Contents/Frameworks/
          install_name_tool -add_rpath @executable_path/../Frameworks "$APP/Contents/MacOS/Speak"

          # Code sign inside-out (innermost first) to preserve Sparkle's
          # XPC service signatures. --deep re-signs nested bundles and breaks
          # Sparkle's installer/downloader XPC services, causing crashes after update.

          # 1. Sign XPC services (innermost bundles)
          for xpc in "$APP"/Contents/Frameworks/Sparkle.framework/Versions/B/XPCServices/*.xpc; do
            codesign --force --sign "$SIGNING_IDENTITY" "$xpc"
          done

          # 2. Sign the Updater helper app
          codesign --force --sign "$SIGNING_IDENTITY" \
            "$APP/Contents/Frameworks/Sparkle.framework/Versions/B/Updater.app"

          # 3. Sign the standalone Autoupdate helper binary
          codesign --force --sign "$SIGNING_IDENTITY" \
            "$APP/Contents/Frameworks/Sparkle.framework/Versions/B/Autoupdate"

          # 4. Sign Sparkle.framework itself
          codesign --force --sign "$SIGNING_IDENTITY" \
            "$APP/Contents/Frameworks/Sparkle.framework"

          # 5. Sign the main app with entitlements + designated requirement
          #    The designated requirement preserves TCC permissions (microphone,
          #    accessibility) across updates by tying them to the bundle ID
          #    rather than the per-build cdhash.
          codesign --force \
            --sign "$SIGNING_IDENTITY" \
            --entitlements Speak/Speak/Speak.entitlements \
            -r='designated => identifier "com.speak.app"' \
            "$APP"

          echo "Signed with identity: $SIGNING_IDENTITY"
          echo "Built: $APP"
          find "$APP" -type f

      # ── Optional: code signing & notarization ──────────────────────
      # Uncomment this section once you have an Apple Developer ID.
      # Required secrets:
      #   DEVELOPER_ID_CERT_BASE64  — base64-encoded .p12 certificate
      #   DEVELOPER_ID_CERT_PASS   — password for the .p12
      #   APPLE_ID                 — your Apple ID email
      #   APPLE_ID_PASSWORD        — app-specific password
      #   APPLE_TEAM_ID            — your team ID
      #
      # - name: Import signing certificate
      #   env:
      #     CERT_BASE64: ${{ secrets.DEVELOPER_ID_CERT_BASE64 }}
      #     CERT_PASS: ${{ secrets.DEVELOPER_ID_CERT_PASS }}
      #   run: |
      #     echo "$CERT_BASE64" | base64 --decode > cert.p12
      #     security create-keychain -p "" build.keychain
      #     security default-keychain -s build.keychain
      #     security unlock-keychain -p "" build.keychain
      #     security import cert.p12 -k build.keychain -P "$CERT_PASS" -T /usr/bin/codesign
      #     security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain
      #     rm cert.p12
      #
      # - name: Sign app
      #   run: |
      #     codesign --force --deep --options runtime \
      #       --sign "Developer ID Application" \
      #       build/Speak.app
      #
      # - name: Notarize app
      #   env:
      #     APPLE_ID: ${{ secrets.APPLE_ID }}
      #     APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
      #     APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      #   run: |
      #     ditto -c -k --keepParent build/Speak.app build/Speak-notarize.zip
      #     xcrun notarytool submit build/Speak-notarize.zip \
      #       --apple-id "$APPLE_ID" \
      #       --password "$APPLE_ID_PASSWORD" \
      #       --team-id "$APPLE_TEAM_ID" \
      #       --wait
      #     xcrun stapler staple build/Speak.app
      # ────────────────────────────────────────────────────────────────

      - name: Create DMG
        run: ./scripts/create-dmg.sh build/Speak.app build/Speak.dmg "${GITHUB_REF_NAME#v}"

      # Also create a zip for users who prefer it / Homebrew casks
      - name: Create zip
        run: ditto -c -k --keepParent build/Speak.app build/Speak.zip

      - name: Download Sparkle CLI tools
        run: |
          SPARKLE_VERSION=$(python3 -c "import json; pins=json.load(open('Speak/Package.resolved'))['pins']; print(next(p['state']['version'] for p in pins if 'sparkle' in p['identity'].lower()))")
          if [ -z "$SPARKLE_VERSION" ]; then
            SPARKLE_VERSION="2.9.0"
          fi
          curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz" -o sparkle.tar.xz
          mkdir -p sparkle-tools
          tar -xf sparkle.tar.xz -C sparkle-tools
          echo "Sparkle CLI tools extracted (v${SPARKLE_VERSION})"

      - name: Sign update with EdDSA
        env:
          SPARKLE_ED_PRIVATE_KEY: ${{ secrets.SPARKLE_ED_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_ED_PRIVATE_KEY" ]; then
            echo "WARNING: SPARKLE_ED_PRIVATE_KEY not set — skipping signing"
            exit 0
          fi
          SIGN_OUTPUT=$(echo "$SPARKLE_ED_PRIVATE_KEY" | sparkle-tools/bin/sign_update --ed-key-file - build/Speak.zip)
          echo "SPARKLE_SIGNATURE<<EOF" >> "$GITHUB_ENV"
          echo "$SIGN_OUTPUT" >> "$GITHUB_ENV"
          echo "EOF" >> "$GITHUB_ENV"
          echo "Signed: $SIGN_OUTPUT"

      - name: Generate appcast
        env:
          SPARKLE_ED_PRIVATE_KEY: ${{ secrets.SPARKLE_ED_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_ED_PRIVATE_KEY" ]; then
            echo "WARNING: SPARKLE_ED_PRIVATE_KEY not set — skipping appcast generation"
            exit 0
          fi
          mkdir -p docs
          # Copy the zip into a staging dir for generate_appcast
          mkdir -p build/appcast-staging
          cp build/Speak.zip build/appcast-staging/
          # If an existing appcast exists, use it as a base
          if [ -f docs/appcast.xml ]; then
            cp docs/appcast.xml build/appcast-staging/
          fi
          echo "$SPARKLE_ED_PRIVATE_KEY" | sparkle-tools/bin/generate_appcast \
            --ed-key-file - \
            --download-url-prefix "https://github.com/chasemcdo/speak/releases/download/${GITHUB_REF_NAME}/" \
            build/appcast-staging
          cp build/appcast-staging/appcast.xml docs/appcast.xml
          echo "Appcast generated at docs/appcast.xml"

      - name: Publish appcast to gh-pages
        run: |
          # Only publish appcast for stable semver tags (vX.Y.Z)
          if ! echo "${GITHUB_REF_NAME}" | grep -qE '^v[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "Skipping appcast publish for non-stable tag: ${GITHUB_REF_NAME}"
            exit 0
          fi
          if [ ! -f docs/appcast.xml ]; then
            echo "No appcast.xml to publish — skipping"
            exit 0
          fi
          cp docs/appcast.xml /tmp/appcast.xml
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          # Create orphan gh-pages branch or check it out
          if git fetch origin gh-pages 2>/dev/null; then
            git checkout gh-pages
          else
            git checkout --orphan gh-pages
            git rm -rf --ignore-unmatch . > /dev/null 2>&1
          fi
          cp /tmp/appcast.xml appcast.xml
          git add appcast.xml
          if git diff --cached --quiet; then
            echo "No appcast changes to publish"
          else
            git commit -m "Update appcast.xml for ${GITHUB_REF_NAME}"
            git push origin gh-pages
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          draft: true
          generate_release_notes: true
          files: |
            build/Speak.dmg
            build/Speak.zip
          body: |
            ## Installation

            1. Download **Speak.dmg** and open it
            2. Drag **Speak** to your Applications folder
            3. On first launch, right-click the app → **Open** (required for unsigned builds)
            4. Grant Microphone and Accessibility permissions when prompted

            > **Note:** This build is not notarized with Apple. macOS will show a warning
            > on first launch. Right-click → Open bypasses this. You only need to do it once.
